import { z } from "zod"
import { dragonBallZCardSchemaWithoutId, DragonBallZCardWithoutId } from "./dragon-ball-z"
import GAME from "./game"
import { pokemonCardSchemaWithoutId, PokemonCardWithoutId } from "./pokemon"
import { yuGiOhCardSchemaWithoutId, YuGiOhCardWithoutId } from "./yu-gi-oh"

// lets you get nested conditional types
export type NestedConditionalType<T> = {
  [K in keyof T]: T[K]
} & {}

export const createCardRequestSchema = z.union([
  yuGiOhCardSchemaWithoutId,
  dragonBallZCardSchemaWithoutId,
  pokemonCardSchemaWithoutId,
])

// CreateCard doesn't have an id field because it will be generated by the server
export type CreateCardRequest = z.infer<typeof createCardRequestSchema>

export const defaultValuesCreateCardRequest = (game: GAME): CreateCardRequest => {
  switch (game) {
    case GAME.YU_GI_OH:
      return {
        game: GAME.YU_GI_OH,
        name: "",
        img: "",
        attack: 0,
        defense: 0,
      } satisfies YuGiOhCardWithoutId
    case GAME.POKEMON:
      return {
        game: GAME.POKEMON,
        name: "",
        img: "",
        type: "normal",
      } satisfies PokemonCardWithoutId
    case GAME.DRAGON_BALL_Z:
      return {
        game: GAME.DRAGON_BALL_Z,
        name: "",
        img: "",
        powerLevel: 0,
      } satisfies DragonBallZCardWithoutId
    default:
      throw new Error("Invalid game type")
  }
}
