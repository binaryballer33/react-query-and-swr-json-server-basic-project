import { z } from "zod"
import { dragonBallZCardSchemaWithoutId } from "./dragon-ball-z"
import GAME from "./game"
import { pokemonCardSchemaWithoutId } from "./pokemon"
import { yuGiOhCardSchemaWithoutId } from "./yu-gi-oh"

// lets you get nested conditional types
export type NestedConditionalType<T> = {
  [K in keyof T]: T[K]
} & {}

export const createCardRequestSchema = z.union([
  yuGiOhCardSchemaWithoutId,
  dragonBallZCardSchemaWithoutId,
  pokemonCardSchemaWithoutId,
])

// CreateCard doesn't have an id field because it will be generated by the server
export type CreateCardRequest = NestedConditionalType<z.infer<typeof createCardRequestSchema>>
// export type CreateCardRequest = z.infer<typeof createCardRequestSchema>

export const defaultValuesCreateCardRequest = (game: GAME): CreateCardRequest => {
  switch (game) {
    case GAME.YU_GI_OH:
      return {
        name: "",
        img: "",
        attack: 0,
        defense: 0,
      }
    case GAME.POKEMON:
      return {
        name: "",
        img: "",
        type: "normal",
      }
    case GAME.DRAGON_BALL_Z:
      return {
        name: "",
        img: "",
        powerLevel: 0,
      }
    default:
      throw new Error("Invalid game type")
  }
}
